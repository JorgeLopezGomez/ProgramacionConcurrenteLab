Teniendo en cuenta lo siguiente:

#include <semaphore.h>

/* Devuelve un puntero al semáforo o SEM FAILED */
sem_t *sem_open (
    const char *name, /* Nombre del semáforo */
    int oflag, /* Flags */
    mode_t mode, /* Permisos */
    unsigned int value /* Valor inicial */
);

sem_t *sem_open (
    const char *name, /* Nombre del semáforo */
    int oflag, /* Flags */
);

Tambien teniendo en cuenta esto 

#include <semaphore.h>

/* Devuelven 0 si todo correcto o -1 en caso de error */
int sem_close (sem_t *sem);
int sem_unlink (const char *name);

y teniendo en cuenta esto:

#include <semaphore.h>

/* Devuelven 0 si todo correcto o -1 en caso de error */
int sem_wait (sem_t *sem);
int sem_post (sem_t *sem);

y por último teniendo en cuenta esto

#include <semaphore.h>

typedef int bool;
#define false 0
#define true 1

/* Crea un semáforo POSIX */
sem_t *crear_sem (const char *name, unsigned int valor);

/* Obtener un semáforo POSIX (ya existente) */
sem_t *get_sem (const char *name);

/* Cierra un semáforo POSIX */
void destruir_sem (const char *name);

/* Incrementa el semáforo */
void signal_sem (sem_t *sem);

/* Decrementa el semáforo */
void wait_sem (sem_t *sem);

Vamos a hacer patron fachada: este consiste en una 
interfaz de gestión de semáforos
propuesta en esta sección es una imple-
mentación del patrón fachada facade.
El diseño de esta interfaz se basa en utilizar un
esquema similar a los semáforos nombrados en PO-
SIX, es decir, identificar a los semáforos por una
cadena de caracteres. Dicha cadena se utilizará pa-
ra crear un semáforo, obtener el puntero a la estructura de tipo sem_t y destruirlo. Sin
embargo, las operaciones wait y signal se realizarán sobre el propio puntero a semáforo.

Tenemos que hacer el siguiente ejercicio:
(Ejercicio calificable en el apartado de Participación y Aprovechamiento
de las clases)
Realizar una implementación del ejemplo de concurrencia descrito a continuación,
utilizando semáforos y variables de memoria compartida en POSIX. Para ello, reutilice el
código del “patrón fachada” que se facilita en los anexos del libro (ejemplo del puente de
un solo carril), compile los diferentes ejecutables utilizando la herramienta <<make>> y un
achivo de especificación Makefile.
Se habilitará una tarea en Campus Virtual de la asignatura para entregar esta tarea optativa
hasta las 23:55 del 20 de marzo.
Ejercicio:
El ejemplo consiste en simular i) retiradas de efectivo e ii) ingresos en un cajero automático,
que pueden ocurrir de manera concurrente (de la manera más sencilla posible). Se plantea
crear dos tipos de procesos (“ahorrador” y “gastón”). El primero hará cierto número de
ingresos modificando una variable de compartida “saldo_en_euros”que irá incrementando
su valor. Hay completa libertad en la implementación, esto quiere decir que puede
considerar un número limitado de ingresos que puede hacer un proceso “ahorrador”, así
como la cantidad de cada ingreso (que puede ser fija o variable, por ejemplo, una cantidad
aleatoria dentro de un rango). Tampoco se define cuantos procesos “ahorradores” hay que
lanzar concurrentemente, lo que se prefiera… puede ser 1, 2 ó n procesos “ahorradores”.
De manera idéntica, se procederá con los procesos “gastones”, dando libertad para
determinar cuántos crear, qué dinero retiran y cuántas veces. Se recomienda desarrollar
un proceso manager, que genere (sea padre) de un número determinado de procesos
“ahorradores” y “gastones” y que también se encargue de crear el/los semáforos
necesarios, así como el/las variables de memoria compartidas para el correcto
funcionamiento en concurrencia (y sin condiciones de carrera) del problema expuesto.
Se entregará un archivo .zip con el código del proyecto (incluyendo el Makefile), incluir
además un pequeño archivo de texto plano .txt con las instrucciones para lanzar el
ejemplo. Durante su ejecución, imprima por pantalla información útil de ingresos y
retiradas para poder “seguir con facilidades” estas operaciones realizadas por los distintos
procesos intervinientes.